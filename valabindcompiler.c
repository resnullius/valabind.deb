/* valabindcompiler.c generated by valac 0.13.1.44-726e, the Vala compiler
 * generated from valabindcompiler.vala, do not modify */

/* Copyleft 2009-2011 -- pancake // nopcode.org */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <vala.h>
#include <glib/gstdio.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_VALABIND_COMPILER (valabind_compiler_get_type ())
#define VALABIND_COMPILER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VALABIND_COMPILER, ValabindCompiler))
#define VALABIND_COMPILER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VALABIND_COMPILER, ValabindCompilerClass))
#define IS_VALABIND_COMPILER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VALABIND_COMPILER))
#define IS_VALABIND_COMPILER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VALABIND_COMPILER))
#define VALABIND_COMPILER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VALABIND_COMPILER, ValabindCompilerClass))

typedef struct _ValabindCompiler ValabindCompiler;
typedef struct _ValabindCompilerClass ValabindCompilerClass;
typedef struct _ValabindCompilerPrivate ValabindCompilerPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_context_unref (var), NULL)))
#define _vala_code_visitor_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_visitor_unref (var), NULL)))
#define _vala_source_file_unref0(var) ((var == NULL) ? NULL : (var = (vala_source_file_unref (var), NULL)))

#define TYPE_GIR_WRITER (gir_writer_get_type ())
#define GIR_WRITER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GIR_WRITER, GirWriter))
#define GIR_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GIR_WRITER, GirWriterClass))
#define IS_GIR_WRITER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GIR_WRITER))
#define IS_GIR_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GIR_WRITER))
#define GIR_WRITER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GIR_WRITER, GirWriterClass))

typedef struct _GirWriter GirWriter;
typedef struct _GirWriterClass GirWriterClass;
typedef struct _GirWriterPrivate GirWriterPrivate;

#define TYPE_GEAR_WRITER (gear_writer_get_type ())
#define GEAR_WRITER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GEAR_WRITER, GearWriter))
#define GEAR_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GEAR_WRITER, GearWriterClass))
#define IS_GEAR_WRITER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GEAR_WRITER))
#define IS_GEAR_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GEAR_WRITER))
#define GEAR_WRITER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GEAR_WRITER, GearWriterClass))

typedef struct _GearWriter GearWriter;
typedef struct _GearWriterClass GearWriterClass;
typedef struct _GearWriterPrivate GearWriterPrivate;

#define TYPE_CXX_WRITER (cxx_writer_get_type ())
#define CXX_WRITER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CXX_WRITER, CxxWriter))
#define CXX_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CXX_WRITER, CxxWriterClass))
#define IS_CXX_WRITER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CXX_WRITER))
#define IS_CXX_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CXX_WRITER))
#define CXX_WRITER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CXX_WRITER, CxxWriterClass))

typedef struct _CxxWriter CxxWriter;
typedef struct _CxxWriterClass CxxWriterClass;
typedef struct _CxxWriterPrivate CxxWriterPrivate;

#define TYPE_SWIG_WRITER (swig_writer_get_type ())
#define SWIG_WRITER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SWIG_WRITER, SwigWriter))
#define SWIG_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SWIG_WRITER, SwigWriterClass))
#define IS_SWIG_WRITER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SWIG_WRITER))
#define IS_SWIG_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SWIG_WRITER))
#define SWIG_WRITER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SWIG_WRITER, SwigWriterClass))

typedef struct _SwigWriter SwigWriter;
typedef struct _SwigWriterClass SwigWriterClass;
typedef struct _SwigWriterPrivate SwigWriterPrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _ParamSpecValabindCompiler ParamSpecValabindCompiler;

struct _ValabindCompiler {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValabindCompilerPrivate * priv;
	gboolean pkgmode;
	gchar* pkgname;
};

struct _ValabindCompilerClass {
	GTypeClass parent_class;
	void (*finalize) (ValabindCompiler *self);
};

struct _ValabindCompilerPrivate {
	gchar* vapidir;
	gchar* modulename;
	ValaCodeContext* context;
	gchar** source_files;
	gint source_files_length1;
	gint _source_files_size_;
};

struct _GirWriter {
	ValaCodeVisitor parent_instance;
	GirWriterPrivate * priv;
	gboolean pkgmode;
	gchar* pkgname;
	gboolean show_externs;
	gboolean glib_mode;
	gboolean cxx_mode;
	gchar** files;
	gint files_length1;
	GList* includefiles;
	GList* methods;
};

struct _GirWriterClass {
	ValaCodeVisitorClass parent_class;
};

struct _GearWriter {
	ValaCodeVisitor parent_instance;
	GearWriterPrivate * priv;
	gboolean pkgmode;
	gchar* pkgname;
	gchar** files;
	gint files_length1;
	GList* includefiles;
	GList* methods;
};

struct _GearWriterClass {
	ValaCodeVisitorClass parent_class;
};

struct _CxxWriter {
	ValaCodeVisitor parent_instance;
	CxxWriterPrivate * priv;
	gboolean pkgmode;
	gchar* pkgname;
	gboolean show_externs;
	gboolean glib_mode;
	gboolean cxx_mode;
	gchar** files;
	gint files_length1;
	GList* includefiles;
	GList* methods;
};

struct _CxxWriterClass {
	ValaCodeVisitorClass parent_class;
};

struct _SwigWriter {
	ValaCodeVisitor parent_instance;
	SwigWriterPrivate * priv;
	gboolean pkgmode;
	gchar* pkgname;
	gboolean show_externs;
	gboolean glib_mode;
	gboolean cxx_mode;
	gchar** files;
	gint files_length1;
	GList* includefiles;
	GList* methods;
};

struct _SwigWriterClass {
	ValaCodeVisitorClass parent_class;
};

struct _ParamSpecValabindCompiler {
	GParamSpec parent_instance;
};


static gpointer valabind_compiler_parent_class = NULL;

gpointer valabind_compiler_ref (gpointer instance);
void valabind_compiler_unref (gpointer instance);
GParamSpec* param_spec_valabind_compiler (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_valabind_compiler (GValue* value, gpointer v_object);
void value_take_valabind_compiler (GValue* value, gpointer v_object);
gpointer value_get_valabind_compiler (const GValue* value);
GType valabind_compiler_get_type (void) G_GNUC_CONST;
#define VALABIND_COMPILER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_VALABIND_COMPILER, ValabindCompilerPrivate))
enum  {
	VALABIND_COMPILER_DUMMY_PROPERTY
};
ValabindCompiler* valabind_compiler_new (const gchar* modulename, const gchar* vapidir, const gchar* profile);
ValabindCompiler* valabind_compiler_construct (GType object_type, const gchar* modulename, const gchar* vapidir, const gchar* profile);
static gboolean valabind_compiler_add_package (ValabindCompiler* self, ValaCodeContext* context, const gchar* pkg);
void valabind_compiler_parse (ValabindCompiler* self);
gboolean valabind_compiler_init (ValabindCompiler* self);
void valabind_compiler_error (const gchar* msg);
gboolean valabind_compiler_add_external_package (ValabindCompiler* self, const gchar* pkg);
gboolean valabind_compiler_add_source_file (ValabindCompiler* self, const gchar* path);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
void valabind_compiler_emit_vapi (ValabindCompiler* self, const gchar* output, const gchar* file);
void valabind_compiler_emit_gir (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include);
GirWriter* gir_writer_new (const gchar* name);
GirWriter* gir_writer_construct (GType object_type, const gchar* name);
GType gir_writer_get_type (void) G_GNUC_CONST;
static gchar** _vala_array_dup1 (gchar** self, int length);
void gir_writer_write_file (GirWriter* self, ValaCodeContext* context, const gchar* filename);
void valabind_compiler_warning (const gchar* msg);
void valabind_compiler_emit_gear (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include);
GearWriter* gear_writer_new (const gchar* name);
GearWriter* gear_writer_construct (GType object_type, const gchar* name);
GType gear_writer_get_type (void) G_GNUC_CONST;
static gchar** _vala_array_dup2 (gchar** self, int length);
void gear_writer_write_file (GearWriter* self, ValaCodeContext* context, const gchar* filename);
void valabind_compiler_emit_cxx (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include);
CxxWriter* cxx_writer_new (const gchar* name);
CxxWriter* cxx_writer_construct (GType object_type, const gchar* name);
GType cxx_writer_get_type (void) G_GNUC_CONST;
static gchar** _vala_array_dup3 (gchar** self, int length);
void cxx_writer_write_file (CxxWriter* self, ValaCodeContext* context, const gchar* filename);
void valabind_compiler_emit_swig (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include);
SwigWriter* swig_writer_new (const gchar* name);
SwigWriter* swig_writer_construct (GType object_type, const gchar* name);
GType swig_writer_get_type (void) G_GNUC_CONST;
static gchar** _vala_array_dup4 (gchar** self, int length);
void swig_writer_write_file (SwigWriter* self, ValaCodeContext* context, const gchar* filename);
static void valabind_compiler_finalize (ValabindCompiler* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


ValabindCompiler* valabind_compiler_construct (GType object_type, const gchar* modulename, const gchar* vapidir, const gchar* profile) {
	ValabindCompiler* self = NULL;
	ValaCodeContext* _tmp0_;
	ValaCodeContext* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	ValaCodeContext* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	gchar** _tmp9_ = NULL;
	ValaCodeContext* _tmp10_;
	ValaCodeContext* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	GQuark _tmp15_ = 0U;
	static GQuark _tmp14_label0 = 0;
	static GQuark _tmp14_label1 = 0;
	g_return_val_if_fail (modulename != NULL, NULL);
	g_return_val_if_fail (vapidir != NULL, NULL);
	g_return_val_if_fail (profile != NULL, NULL);
	self = (ValabindCompiler*) g_type_create_instance (object_type);
	_tmp0_ = vala_code_context_new ();
	_vala_code_context_unref0 (self->priv->context);
	self->priv->context = _tmp0_;
	_tmp1_ = self->priv->context;
	vala_code_context_push (_tmp1_);
	_tmp2_ = modulename;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->priv->modulename);
	self->priv->modulename = _tmp3_;
	_tmp4_ = vapidir;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->priv->vapidir);
	self->priv->vapidir = _tmp5_;
	_tmp6_ = self->priv->context;
	_tmp7_ = vapidir;
	_tmp8_ = g_strdup (_tmp7_);
	_tmp9_ = g_new0 (gchar*, 1 + 1);
	_tmp9_[0] = _tmp8_;
	_tmp6_->vapi_directories = (_vala_array_free (_tmp6_->vapi_directories, _tmp6_->vapi_directories_length1, (GDestroyNotify) g_free), NULL);
	_tmp6_->vapi_directories = _tmp9_;
	_tmp6_->vapi_directories_length1 = 1;
	self->priv->source_files = (_vala_array_free (self->priv->source_files, self->priv->source_files_length1, (GDestroyNotify) g_free), NULL);
	self->priv->source_files = NULL;
	self->priv->source_files_length1 = 0;
	self->priv->_source_files_size_ = self->priv->source_files_length1;
	_tmp10_ = self->priv->context;
	valabind_compiler_add_package (self, _tmp10_, "glib-2.0");
	_tmp11_ = self->priv->context;
	valabind_compiler_add_package (self, _tmp11_, "gobject-2.0");
	_tmp12_ = profile;
	_tmp13_ = _tmp12_;
	_tmp15_ = (NULL == _tmp13_) ? 0 : g_quark_from_string (_tmp13_);
	if (_tmp15_ == ((0 != _tmp14_label0) ? _tmp14_label0 : (_tmp14_label0 = g_quark_from_static_string ("gobject")))) {
		switch (0) {
			default:
			{
				ValaCodeContext* _tmp16_;
				ValaCodeContext* _tmp17_;
				_tmp16_ = self->priv->context;
				vala_code_context_set_profile (_tmp16_, VALA_PROFILE_GOBJECT);
				_tmp17_ = self->priv->context;
				vala_code_context_add_define (_tmp17_, "GOBJECT");
				break;
			}
		}
	} else if (_tmp15_ == ((0 != _tmp14_label1) ? _tmp14_label1 : (_tmp14_label1 = g_quark_from_static_string ("dova")))) {
		switch (0) {
			default:
			{
				ValaCodeContext* _tmp18_;
				ValaCodeContext* _tmp19_;
				_tmp18_ = self->priv->context;
				vala_code_context_set_profile (_tmp18_, VALA_PROFILE_DOVA);
				_tmp19_ = self->priv->context;
				vala_code_context_add_define (_tmp19_, "DOVA");
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				ValaCodeContext* _tmp20_;
				ValaCodeContext* _tmp21_;
				_tmp20_ = self->priv->context;
				vala_code_context_set_profile (_tmp20_, VALA_PROFILE_POSIX);
				_tmp21_ = self->priv->context;
				vala_code_context_add_define (_tmp21_, "POSIX");
				break;
			}
		}
	}
	return self;
}


ValabindCompiler* valabind_compiler_new (const gchar* modulename, const gchar* vapidir, const gchar* profile) {
	return valabind_compiler_construct (TYPE_VALABIND_COMPILER, modulename, vapidir, profile);
}


void valabind_compiler_parse (ValabindCompiler* self) {
	ValaParser* _tmp0_;
	ValaParser* parser;
	ValaParser* _tmp1_;
	ValaCodeContext* _tmp2_;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = vala_parser_new ();
	parser = _tmp0_;
	_tmp1_ = parser;
	_tmp2_ = self->priv->context;
	vala_parser_parse (_tmp1_, _tmp2_);
	_tmp3_ = valabind_compiler_init (self);
	if (!_tmp3_) {
		valabind_compiler_error ("valabind initialization failed");
	}
	_vala_code_visitor_unref0 (parser);
}


gboolean valabind_compiler_init (ValabindCompiler* self) {
	gboolean result = FALSE;
	ValaCodeContext* _tmp0_;
	ValaCodeContext* _tmp1_;
	ValaReport* _tmp2_ = NULL;
	ValaReport* _tmp3_;
	gint _tmp4_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->context;
	vala_code_context_check (_tmp0_);
	_tmp1_ = self->priv->context;
	_tmp2_ = vala_code_context_get_report (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = vala_report_get_errors (_tmp3_);
	result = _tmp4_ == 0;
	return result;
}


gboolean valabind_compiler_add_external_package (ValabindCompiler* self, const gchar* pkg) {
	gboolean result = FALSE;
	ValaCodeContext* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pkg != NULL, FALSE);
	_tmp0_ = self->priv->context;
	_tmp1_ = pkg;
	_tmp2_ = vala_code_context_add_external_package (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


gboolean valabind_compiler_add_source_file (ValabindCompiler* self, const gchar* path) {
	gboolean result = FALSE;
	gchar** _tmp0_;
	gint _tmp0__length1;
	const gchar* _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean ret;
	gboolean _tmp6_;
	gboolean _tmp22_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	_tmp0_ = self->priv->source_files;
	_tmp0__length1 = self->priv->source_files_length1;
	{
		gchar** f_collection = NULL;
		gint f_collection_length1 = 0;
		gint _f_collection_size_ = 0;
		gint f_it = 0;
		f_collection = _tmp0_;
		f_collection_length1 = _tmp0__length1;
		for (f_it = 0; f_it < _tmp0__length1; f_it = f_it + 1) {
			gchar* _tmp1_;
			gchar* f = NULL;
			_tmp1_ = g_strdup (f_collection[f_it]);
			f = _tmp1_;
			{
				const gchar* _tmp2_;
				const gchar* _tmp3_;
				_tmp2_ = path;
				_tmp3_ = f;
				if (g_strcmp0 (_tmp2_, _tmp3_) == 0) {
					result = FALSE;
					_g_free0 (f);
					return result;
				}
				_g_free0 (f);
			}
		}
	}
	_tmp4_ = path;
	_tmp5_ = g_file_test (_tmp4_, G_FILE_TEST_IS_REGULAR);
	ret = _tmp5_;
	_tmp6_ = ret;
	if (_tmp6_) {
		gboolean _tmp7_;
		gchar** _tmp13_;
		gint _tmp13__length1;
		const gchar* _tmp14_;
		gchar* _tmp15_;
		_tmp7_ = self->pkgmode;
		if (!_tmp7_) {
			ValaCodeContext* _tmp8_;
			ValaCodeContext* _tmp9_;
			const gchar* _tmp10_;
			ValaSourceFile* _tmp11_;
			ValaSourceFile* _tmp12_;
			_tmp8_ = self->priv->context;
			_tmp9_ = self->priv->context;
			_tmp10_ = path;
			_tmp11_ = vala_source_file_new (_tmp9_, VALA_SOURCE_FILE_TYPE_PACKAGE, _tmp10_, NULL);
			_tmp12_ = _tmp11_;
			vala_code_context_add_source_file (_tmp8_, _tmp12_);
			_vala_source_file_unref0 (_tmp12_);
		}
		_tmp13_ = self->priv->source_files;
		_tmp13__length1 = self->priv->source_files_length1;
		_tmp14_ = path;
		_tmp15_ = g_strdup (_tmp14_);
		_vala_array_add1 (&self->priv->source_files, &self->priv->source_files_length1, &self->priv->_source_files_size_, _tmp15_);
	} else {
		ValaCodeContext* _tmp16_;
		const gchar* _tmp17_;
		gboolean _tmp18_ = FALSE;
		_tmp16_ = self->priv->context;
		_tmp17_ = path;
		_tmp18_ = valabind_compiler_add_package (self, _tmp16_, _tmp17_);
		if (!_tmp18_) {
			const gchar* _tmp19_;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_;
			_tmp19_ = path;
			_tmp20_ = g_strdup_printf ("Cannot find '%s'.\n", _tmp19_);
			_tmp21_ = _tmp20_;
			valabind_compiler_error (_tmp21_);
			_g_free0 (_tmp21_);
		}
	}
	_tmp22_ = ret;
	result = _tmp22_;
	return result;
}


void valabind_compiler_emit_vapi (ValabindCompiler* self, const gchar* output, const gchar* file) {
	ValaCodeWriter* _tmp0_;
	ValaCodeWriter* swig_writer;
	ValaCodeWriter* _tmp1_;
	ValaCodeContext* _tmp2_;
	const gchar* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = vala_code_writer_new (VALA_CODE_WRITER_TYPE_EXTERNAL);
	swig_writer = _tmp0_;
	_tmp1_ = swig_writer;
	_tmp2_ = self->priv->context;
	_tmp3_ = file;
	vala_code_writer_write_file (_tmp1_, _tmp2_, _tmp3_);
	_vala_code_visitor_unref0 (swig_writer);
}


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


void valabind_compiler_emit_gir (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include) {
	const gchar* _tmp0_;
	GirWriter* _tmp1_;
	GirWriter* gir_writer;
	GirWriter* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = self->priv->modulename;
	_tmp1_ = gir_writer_new (_tmp0_);
	gir_writer = _tmp1_;
	_tmp2_ = gir_writer;
	if (_tmp2_ != NULL) {
		GirWriter* _tmp3_;
		gboolean _tmp4_;
		GirWriter* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		const gchar* _tmp8_;
		GirWriter* _tmp12_;
		gchar** _tmp13_;
		gint _tmp13__length1;
		gchar** _tmp14_;
		gint _tmp14__length1;
		GirWriter* _tmp15_;
		ValaCodeContext* _tmp16_;
		const gchar* _tmp17_;
		_tmp3_ = gir_writer;
		_tmp4_ = self->pkgmode;
		_tmp3_->pkgmode = _tmp4_;
		_tmp5_ = gir_writer;
		_tmp6_ = self->pkgname;
		_tmp7_ = g_strdup (_tmp6_);
		_g_free0 (_tmp5_->pkgname);
		_tmp5_->pkgname = _tmp7_;
		_tmp8_ = include;
		if (_tmp8_ != NULL) {
			GirWriter* _tmp9_;
			const gchar* _tmp10_;
			gchar* _tmp11_;
			_tmp9_ = gir_writer;
			_tmp10_ = include;
			_tmp11_ = g_strdup (_tmp10_);
			_tmp9_->includefiles = g_list_append (_tmp9_->includefiles, _tmp11_);
		}
		_tmp12_ = gir_writer;
		_tmp13_ = self->priv->source_files;
		_tmp13__length1 = self->priv->source_files_length1;
		_tmp14_ = (_tmp13_ != NULL) ? _vala_array_dup1 (_tmp13_, _tmp13__length1) : ((gpointer) _tmp13_);
		_tmp14__length1 = _tmp13__length1;
		_tmp12_->files = (_vala_array_free (_tmp12_->files, _tmp12_->files_length1, (GDestroyNotify) g_free), NULL);
		_tmp12_->files = _tmp14_;
		_tmp12_->files_length1 = _tmp14__length1;
		_tmp15_ = gir_writer;
		_tmp16_ = self->priv->context;
		_tmp17_ = file;
		gir_writer_write_file (_tmp15_, _tmp16_, _tmp17_);
	} else {
		valabind_compiler_warning ("cannot create swig writer");
	}
	_vala_code_visitor_unref0 (gir_writer);
}


static gchar** _vala_array_dup2 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


void valabind_compiler_emit_gear (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include) {
	const gchar* _tmp0_;
	GearWriter* _tmp1_;
	GearWriter* gear_writer;
	GearWriter* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = self->priv->modulename;
	_tmp1_ = gear_writer_new (_tmp0_);
	gear_writer = _tmp1_;
	_tmp2_ = gear_writer;
	if (_tmp2_ != NULL) {
		GearWriter* _tmp3_;
		gboolean _tmp4_;
		GearWriter* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		const gchar* _tmp8_;
		GearWriter* _tmp12_;
		gchar** _tmp13_;
		gint _tmp13__length1;
		gchar** _tmp14_;
		gint _tmp14__length1;
		GearWriter* _tmp15_;
		ValaCodeContext* _tmp16_;
		const gchar* _tmp17_;
		_tmp3_ = gear_writer;
		_tmp4_ = self->pkgmode;
		_tmp3_->pkgmode = _tmp4_;
		_tmp5_ = gear_writer;
		_tmp6_ = self->pkgname;
		_tmp7_ = g_strdup (_tmp6_);
		_g_free0 (_tmp5_->pkgname);
		_tmp5_->pkgname = _tmp7_;
		_tmp8_ = include;
		if (_tmp8_ != NULL) {
			GearWriter* _tmp9_;
			const gchar* _tmp10_;
			gchar* _tmp11_;
			_tmp9_ = gear_writer;
			_tmp10_ = include;
			_tmp11_ = g_strdup (_tmp10_);
			_tmp9_->includefiles = g_list_append (_tmp9_->includefiles, _tmp11_);
		}
		_tmp12_ = gear_writer;
		_tmp13_ = self->priv->source_files;
		_tmp13__length1 = self->priv->source_files_length1;
		_tmp14_ = (_tmp13_ != NULL) ? _vala_array_dup2 (_tmp13_, _tmp13__length1) : ((gpointer) _tmp13_);
		_tmp14__length1 = _tmp13__length1;
		_tmp12_->files = (_vala_array_free (_tmp12_->files, _tmp12_->files_length1, (GDestroyNotify) g_free), NULL);
		_tmp12_->files = _tmp14_;
		_tmp12_->files_length1 = _tmp14__length1;
		_tmp15_ = gear_writer;
		_tmp16_ = self->priv->context;
		_tmp17_ = file;
		gear_writer_write_file (_tmp15_, _tmp16_, _tmp17_);
	} else {
		valabind_compiler_warning ("cannot create swig writer");
	}
	_vala_code_visitor_unref0 (gear_writer);
}


static gchar** _vala_array_dup3 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


void valabind_compiler_emit_cxx (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include) {
	const gchar* _tmp0_;
	CxxWriter* _tmp1_;
	CxxWriter* cxx_writer;
	CxxWriter* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = self->priv->modulename;
	_tmp1_ = cxx_writer_new (_tmp0_);
	cxx_writer = _tmp1_;
	_tmp2_ = cxx_writer;
	if (_tmp2_ != NULL) {
		CxxWriter* _tmp3_;
		gboolean _tmp4_;
		CxxWriter* _tmp5_;
		gboolean _tmp6_;
		CxxWriter* _tmp7_;
		gboolean _tmp8_;
		CxxWriter* _tmp9_;
		gboolean _tmp10_;
		CxxWriter* _tmp11_;
		const gchar* _tmp12_;
		gchar* _tmp13_;
		const gchar* _tmp14_;
		CxxWriter* _tmp18_;
		gchar** _tmp19_;
		gint _tmp19__length1;
		gchar** _tmp20_;
		gint _tmp20__length1;
		CxxWriter* _tmp21_;
		ValaCodeContext* _tmp22_;
		const gchar* _tmp23_;
		_tmp3_ = cxx_writer;
		_tmp4_ = show_externs;
		_tmp3_->show_externs = _tmp4_;
		_tmp5_ = cxx_writer;
		_tmp6_ = glibmode;
		_tmp5_->glib_mode = _tmp6_;
		_tmp7_ = cxx_writer;
		_tmp8_ = cxxmode;
		_tmp7_->cxx_mode = _tmp8_;
		_tmp9_ = cxx_writer;
		_tmp10_ = self->pkgmode;
		_tmp9_->pkgmode = _tmp10_;
		_tmp11_ = cxx_writer;
		_tmp12_ = self->pkgname;
		_tmp13_ = g_strdup (_tmp12_);
		_g_free0 (_tmp11_->pkgname);
		_tmp11_->pkgname = _tmp13_;
		_tmp14_ = include;
		if (_tmp14_ != NULL) {
			CxxWriter* _tmp15_;
			const gchar* _tmp16_;
			gchar* _tmp17_;
			_tmp15_ = cxx_writer;
			_tmp16_ = include;
			_tmp17_ = g_strdup (_tmp16_);
			_tmp15_->includefiles = g_list_append (_tmp15_->includefiles, _tmp17_);
		}
		_tmp18_ = cxx_writer;
		_tmp19_ = self->priv->source_files;
		_tmp19__length1 = self->priv->source_files_length1;
		_tmp20_ = (_tmp19_ != NULL) ? _vala_array_dup3 (_tmp19_, _tmp19__length1) : ((gpointer) _tmp19_);
		_tmp20__length1 = _tmp19__length1;
		_tmp18_->files = (_vala_array_free (_tmp18_->files, _tmp18_->files_length1, (GDestroyNotify) g_free), NULL);
		_tmp18_->files = _tmp20_;
		_tmp18_->files_length1 = _tmp20__length1;
		_tmp21_ = cxx_writer;
		_tmp22_ = self->priv->context;
		_tmp23_ = file;
		cxx_writer_write_file (_tmp21_, _tmp22_, _tmp23_);
	} else {
		valabind_compiler_warning ("cannot create swig writer");
	}
	_vala_code_visitor_unref0 (cxx_writer);
}


static gchar** _vala_array_dup4 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


void valabind_compiler_emit_swig (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include) {
	const gchar* _tmp0_;
	SwigWriter* _tmp1_;
	SwigWriter* swig_writer;
	SwigWriter* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	_tmp0_ = self->priv->modulename;
	_tmp1_ = swig_writer_new (_tmp0_);
	swig_writer = _tmp1_;
	_tmp2_ = swig_writer;
	if (_tmp2_ != NULL) {
		SwigWriter* _tmp3_;
		gboolean _tmp4_;
		SwigWriter* _tmp5_;
		gboolean _tmp6_;
		SwigWriter* _tmp7_;
		gboolean _tmp8_;
		SwigWriter* _tmp9_;
		gboolean _tmp10_;
		SwigWriter* _tmp11_;
		const gchar* _tmp12_;
		gchar* _tmp13_;
		const gchar* _tmp14_;
		SwigWriter* _tmp18_;
		gchar** _tmp19_;
		gint _tmp19__length1;
		gchar** _tmp20_;
		gint _tmp20__length1;
		SwigWriter* _tmp21_;
		ValaCodeContext* _tmp22_;
		const gchar* _tmp23_;
		_tmp3_ = swig_writer;
		_tmp4_ = show_externs;
		_tmp3_->show_externs = _tmp4_;
		_tmp5_ = swig_writer;
		_tmp6_ = glibmode;
		_tmp5_->glib_mode = _tmp6_;
		_tmp7_ = swig_writer;
		_tmp8_ = cxxmode;
		_tmp7_->cxx_mode = _tmp8_;
		_tmp9_ = swig_writer;
		_tmp10_ = self->pkgmode;
		_tmp9_->pkgmode = _tmp10_;
		_tmp11_ = swig_writer;
		_tmp12_ = self->pkgname;
		_tmp13_ = g_strdup (_tmp12_);
		_g_free0 (_tmp11_->pkgname);
		_tmp11_->pkgname = _tmp13_;
		_tmp14_ = include;
		if (_tmp14_ != NULL) {
			SwigWriter* _tmp15_;
			const gchar* _tmp16_;
			gchar* _tmp17_;
			_tmp15_ = swig_writer;
			_tmp16_ = include;
			_tmp17_ = g_strdup (_tmp16_);
			_tmp15_->includefiles = g_list_append (_tmp15_->includefiles, _tmp17_);
		}
		_tmp18_ = swig_writer;
		_tmp19_ = self->priv->source_files;
		_tmp19__length1 = self->priv->source_files_length1;
		_tmp20_ = (_tmp19_ != NULL) ? _vala_array_dup4 (_tmp19_, _tmp19__length1) : ((gpointer) _tmp19_);
		_tmp20__length1 = _tmp19__length1;
		_tmp18_->files = (_vala_array_free (_tmp18_->files, _tmp18_->files_length1, (GDestroyNotify) g_free), NULL);
		_tmp18_->files = _tmp20_;
		_tmp18_->files_length1 = _tmp20__length1;
		_tmp21_ = swig_writer;
		_tmp22_ = self->priv->context;
		_tmp23_ = file;
		swig_writer_write_file (_tmp21_, _tmp22_, _tmp23_);
	} else {
		valabind_compiler_warning ("cannot create swig writer");
	}
	_vala_code_visitor_unref0 (swig_writer);
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	_tmp2_ = _result_;
	result = _tmp2_;
	return result;
}


static gboolean valabind_compiler_add_package (ValabindCompiler* self, ValaCodeContext* context, const gchar* pkg) {
	gboolean result = FALSE;
	const gchar* _tmp0_;
	ValaCodeContext* _tmp1_;
	const gchar* _tmp2_;
	gboolean _tmp3_ = FALSE;
	ValaCodeContext* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* package_path;
	const gchar* _tmp7_;
	gboolean _tmp10_;
	ValaCodeContext* _tmp12_;
	ValaCodeContext* _tmp13_;
	const gchar* _tmp14_;
	ValaSourceFile* _tmp15_;
	ValaSourceFile* _tmp16_;
	ValaCodeContext* _tmp17_;
	const gchar* _tmp18_;
	const gchar* _tmp19_;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_;
	const gchar* _tmp22_;
	gchar* _tmp23_ = NULL;
	gchar* _tmp24_;
	gchar* _tmp25_ = NULL;
	gchar* _tmp26_;
	gchar* deps_filename;
	const gchar* _tmp27_;
	gboolean _tmp28_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (context != NULL, FALSE);
	g_return_val_if_fail (pkg != NULL, FALSE);
	_tmp0_ = pkg;
	g_print ("Adding dependency package %s\n", _tmp0_);
	_tmp1_ = context;
	_tmp2_ = pkg;
	_tmp3_ = vala_code_context_has_package (_tmp1_, _tmp2_);
	if (_tmp3_) {
		result = TRUE;
		return result;
	}
	_tmp4_ = context;
	_tmp5_ = pkg;
	_tmp6_ = vala_code_context_get_vapi_path (_tmp4_, _tmp5_);
	package_path = _tmp6_;
	_tmp7_ = package_path;
	if (_tmp7_ == NULL) {
		FILE* _tmp8_;
		const gchar* _tmp9_;
		_tmp8_ = stderr;
		_tmp9_ = pkg;
		fprintf (_tmp8_, "Cannot find package path '%s'", _tmp9_);
		result = FALSE;
		_g_free0 (package_path);
		return result;
	}
	_tmp10_ = self->pkgmode;
	if (_tmp10_) {
		const gchar* _tmp11_;
		_tmp11_ = package_path;
		valabind_compiler_add_source_file (self, _tmp11_);
	}
	_tmp12_ = context;
	_tmp13_ = context;
	_tmp14_ = package_path;
	_tmp15_ = vala_source_file_new (_tmp13_, VALA_SOURCE_FILE_TYPE_PACKAGE, _tmp14_, NULL);
	_tmp16_ = _tmp15_;
	vala_code_context_add_source_file (_tmp12_, _tmp16_);
	_vala_source_file_unref0 (_tmp16_);
	_tmp17_ = context;
	_tmp18_ = pkg;
	vala_code_context_add_package (_tmp17_, _tmp18_);
	_tmp19_ = package_path;
	_tmp20_ = g_path_get_dirname (_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = pkg;
	_tmp23_ = g_strdup_printf ("%s.deps", _tmp22_);
	_tmp24_ = _tmp23_;
	_tmp25_ = g_build_filename (_tmp21_, _tmp24_, NULL);
	_tmp26_ = _tmp25_;
	_g_free0 (_tmp24_);
	_g_free0 (_tmp21_);
	deps_filename = _tmp26_;
	_tmp27_ = deps_filename;
	_tmp28_ = g_file_test (_tmp27_, G_FILE_TEST_EXISTS);
	if (_tmp28_) {
		{
			gchar* deps_content = NULL;
			gsize deps_len = 0UL;
			const gchar* _tmp29_;
			gchar* _tmp30_ = NULL;
			gsize _tmp31_ = 0UL;
			const gchar* _tmp32_;
			gchar** _tmp33_;
			gchar** _tmp34_ = NULL;
			_tmp29_ = deps_filename;
			g_file_get_contents (_tmp29_, &_tmp30_, &_tmp31_, &_inner_error_);
			_g_free0 (deps_content);
			deps_content = _tmp30_;
			deps_len = _tmp31_;
			if (_inner_error_ != NULL) {
				_g_free0 (deps_content);
				if (_inner_error_->domain == G_FILE_ERROR) {
					goto __catch1_g_file_error;
				}
				_g_free0 (deps_content);
				_g_free0 (deps_filename);
				_g_free0 (package_path);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
			_tmp32_ = deps_content;
			_tmp34_ = _tmp33_ = g_strsplit (_tmp32_, "\n", 0);
			{
				gchar** dep_collection = NULL;
				gint dep_collection_length1 = 0;
				gint _dep_collection_size_ = 0;
				gint dep_it = 0;
				dep_collection = _tmp34_;
				dep_collection_length1 = _vala_array_length (_tmp33_);
				for (dep_it = 0; dep_it < _vala_array_length (_tmp33_); dep_it = dep_it + 1) {
					gchar* _tmp35_;
					gchar* dep = NULL;
					_tmp35_ = g_strdup (dep_collection[dep_it]);
					dep = _tmp35_;
					{
						const gchar* _tmp36_;
						gchar* _tmp37_ = NULL;
						const gchar* _tmp38_;
						_tmp36_ = dep;
						_tmp37_ = string_strip (_tmp36_);
						_g_free0 (dep);
						dep = _tmp37_;
						_tmp38_ = dep;
						if (g_strcmp0 (_tmp38_, "") != 0) {
							ValaCodeContext* _tmp39_;
							const gchar* _tmp40_;
							gboolean _tmp41_ = FALSE;
							_tmp39_ = context;
							_tmp40_ = dep;
							_tmp41_ = valabind_compiler_add_package (self, _tmp39_, _tmp40_);
							if (!_tmp41_) {
								const gchar* _tmp42_;
								const gchar* _tmp43_;
								gchar* _tmp44_ = NULL;
								gchar* _tmp45_;
								_tmp42_ = dep;
								_tmp43_ = pkg;
								_tmp44_ = g_strdup_printf ("%s, dependency of %s, not found in specified Vala API directories", _tmp42_, _tmp43_);
								_tmp45_ = _tmp44_;
								vala_report_error (NULL, _tmp45_);
								_g_free0 (_tmp45_);
							}
						}
						_g_free0 (dep);
					}
				}
				dep_collection = (_vala_array_free (dep_collection, dep_collection_length1, (GDestroyNotify) g_free), NULL);
			}
			_g_free0 (deps_content);
		}
		goto __finally1;
		__catch1_g_file_error:
		{
			GError* e = NULL;
			GError* _tmp46_;
			const gchar* _tmp47_;
			gchar* _tmp48_ = NULL;
			gchar* _tmp49_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp46_ = e;
			_tmp47_ = _tmp46_->message;
			_tmp48_ = g_strdup_printf ("Unable to read dependency file: %s", _tmp47_);
			_tmp49_ = _tmp48_;
			vala_report_error (NULL, _tmp49_);
			_g_free0 (_tmp49_);
			_g_error_free0 (e);
		}
		__finally1:
		if (_inner_error_ != NULL) {
			_g_free0 (deps_filename);
			_g_free0 (package_path);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	result = TRUE;
	_g_free0 (deps_filename);
	_g_free0 (package_path);
	return result;
}


void valabind_compiler_error (const gchar* msg) {
	FILE* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (msg != NULL);
	_tmp0_ = stderr;
	_tmp1_ = msg;
	fprintf (_tmp0_, "\x1b[31mERROR:\x1b[0m %s\n", _tmp1_);
	exit (1);
}


void valabind_compiler_warning (const gchar* msg) {
	FILE* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (msg != NULL);
	_tmp0_ = stderr;
	_tmp1_ = msg;
	fprintf (_tmp0_, "\x1b[33mWARNING:\x1b[0m %s\n", _tmp1_);
}


static void value_valabind_compiler_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_valabind_compiler_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		valabind_compiler_unref (value->data[0].v_pointer);
	}
}


static void value_valabind_compiler_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = valabind_compiler_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_valabind_compiler_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_valabind_compiler_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ValabindCompiler* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = valabind_compiler_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_valabind_compiler_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ValabindCompiler** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = valabind_compiler_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_valabind_compiler (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecValabindCompiler* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_VALABIND_COMPILER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_valabind_compiler (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_VALABIND_COMPILER), NULL);
	return value->data[0].v_pointer;
}


void value_set_valabind_compiler (GValue* value, gpointer v_object) {
	ValabindCompiler* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_VALABIND_COMPILER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_VALABIND_COMPILER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		valabind_compiler_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		valabind_compiler_unref (old);
	}
}


void value_take_valabind_compiler (GValue* value, gpointer v_object) {
	ValabindCompiler* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_VALABIND_COMPILER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_VALABIND_COMPILER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		valabind_compiler_unref (old);
	}
}


static void valabind_compiler_class_init (ValabindCompilerClass * klass) {
	valabind_compiler_parent_class = g_type_class_peek_parent (klass);
	VALABIND_COMPILER_CLASS (klass)->finalize = valabind_compiler_finalize;
	g_type_class_add_private (klass, sizeof (ValabindCompilerPrivate));
}


static void valabind_compiler_instance_init (ValabindCompiler * self) {
	self->priv = VALABIND_COMPILER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void valabind_compiler_finalize (ValabindCompiler* obj) {
	ValabindCompiler * self;
	self = VALABIND_COMPILER (obj);
	_g_free0 (self->priv->vapidir);
	_g_free0 (self->priv->modulename);
	_vala_code_context_unref0 (self->priv->context);
	_g_free0 (self->pkgname);
	self->priv->source_files = (_vala_array_free (self->priv->source_files, self->priv->source_files_length1, (GDestroyNotify) g_free), NULL);
}


GType valabind_compiler_get_type (void) {
	static volatile gsize valabind_compiler_type_id__volatile = 0;
	if (g_once_init_enter (&valabind_compiler_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_valabind_compiler_init, value_valabind_compiler_free_value, value_valabind_compiler_copy_value, value_valabind_compiler_peek_pointer, "p", value_valabind_compiler_collect_value, "p", value_valabind_compiler_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ValabindCompilerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valabind_compiler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValabindCompiler), 0, (GInstanceInitFunc) valabind_compiler_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType valabind_compiler_type_id;
		valabind_compiler_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ValabindCompiler", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&valabind_compiler_type_id__volatile, valabind_compiler_type_id);
	}
	return valabind_compiler_type_id__volatile;
}


gpointer valabind_compiler_ref (gpointer instance) {
	ValabindCompiler* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void valabind_compiler_unref (gpointer instance) {
	ValabindCompiler* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		VALABIND_COMPILER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



