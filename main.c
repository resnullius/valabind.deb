/* main.c generated by valac 0.13.1.44-726e, the Vala compiler
 * generated from main.vala, do not modify */

/* Copyleft 2009-2011 -- pancake // nopcode.org */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_VALABIND_COMPILER (valabind_compiler_get_type ())
#define VALABIND_COMPILER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VALABIND_COMPILER, ValabindCompiler))
#define VALABIND_COMPILER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VALABIND_COMPILER, ValabindCompilerClass))
#define IS_VALABIND_COMPILER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VALABIND_COMPILER))
#define IS_VALABIND_COMPILER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VALABIND_COMPILER))
#define VALABIND_COMPILER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VALABIND_COMPILER, ValabindCompilerClass))

typedef struct _ValabindCompiler ValabindCompiler;
typedef struct _ValabindCompilerClass ValabindCompilerClass;
typedef struct _ValabindCompilerPrivate ValabindCompilerPrivate;
#define _valabind_compiler_unref0(var) ((var == NULL) ? NULL : (var = (valabind_compiler_unref (var), NULL)))

struct _ValabindCompiler {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValabindCompilerPrivate * priv;
	gboolean pkgmode;
	gchar* pkgname;
};

struct _ValabindCompilerClass {
	GTypeClass parent_class;
	void (*finalize) (ValabindCompiler *self);
};


extern gchar** files;
extern gint files_length1;
gchar** files = NULL;
gint files_length1 = 0;
static gint _files_size_ = 0;
extern gchar* includefile;
gchar* includefile = NULL;
extern gchar* vapidir;
gchar* vapidir = NULL;
extern gboolean show_version;
gboolean show_version = FALSE;
extern gboolean show_externs;
gboolean show_externs = FALSE;
extern gboolean glibmode;
gboolean glibmode = FALSE;
extern gboolean cxxmode;
gboolean cxxmode = FALSE;
extern gboolean cxxoutput;
gboolean cxxoutput = FALSE;
extern gboolean gearoutput;
gboolean gearoutput = FALSE;
extern gboolean swigoutput;
gboolean swigoutput = FALSE;
extern gboolean giroutput;
gboolean giroutput = FALSE;
extern gchar* modulename;
gchar* modulename = NULL;
extern gchar* output;
gchar* output = NULL;
extern gchar* useprofile;
gchar* useprofile = NULL;
extern gchar** packages;
gchar** packages = NULL;

gint _vala_main (gchar** args, int args_length1);
#define version_string "valabind 0.4.5 - pancake@nopcode.org"
ValabindCompiler* valabind_compiler_new (const gchar* modulename, const gchar* vapidir, const gchar* profile);
ValabindCompiler* valabind_compiler_construct (GType object_type, const gchar* modulename, const gchar* vapidir, const gchar* profile);
gpointer valabind_compiler_ref (gpointer instance);
void valabind_compiler_unref (gpointer instance);
GParamSpec* param_spec_valabind_compiler (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_valabind_compiler (GValue* value, gpointer v_object);
void value_take_valabind_compiler (GValue* value, gpointer v_object);
gpointer value_get_valabind_compiler (const GValue* value);
GType valabind_compiler_get_type (void) G_GNUC_CONST;
gboolean valabind_compiler_add_external_package (ValabindCompiler* self, const gchar* pkg);
gboolean valabind_compiler_add_source_file (ValabindCompiler* self, const gchar* path);
void valabind_compiler_parse (ValabindCompiler* self);
void valabind_compiler_emit_gear (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include);
void valabind_compiler_emit_gir (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include);
void valabind_compiler_emit_cxx (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include);
void valabind_compiler_emit_swig (ValabindCompiler* self, const gchar* file, gboolean show_externs, gboolean glibmode, gboolean cxxmode, const gchar* include);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

const GOptionEntry options[16] = {{"pkg", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &packages, "Include binding for PACKAGE", "PACKAGE..."}, {"vapidir", 'V', 0, G_OPTION_ARG_STRING, &vapidir, "define alternative vapi directory", NULL}, {"include", 'i', 0, G_OPTION_ARG_STRING, &includefile, "include file", NULL}, {"externs", 'e', 0, G_OPTION_ARG_NONE, &show_externs, "render externs", NULL}, {"version", 'v', 0, G_OPTION_ARG_NONE, &show_version, "show version information", NULL}, {"output", 'o', 0, G_OPTION_ARG_STRING, &output, "specify output file name", NULL}, {"module", 'm', 0, G_OPTION_ARG_STRING, &modulename, "specify module name", "NAME"}, {"profile", 'p', 0, G_OPTION_ARG_NONE, &useprofile, "select Vala profile (posix, gobject, dova)", "posix"}, {"glib", 'g', 0, G_OPTION_ARG_NONE, &glibmode, "work in glib/gobject mode", NULL}, {"cxx-swig", 'x', 0, G_OPTION_ARG_NONE, &cxxmode, "generate c++ code for SWIG", NULL}, {"swig", '\0', 0, G_OPTION_ARG_NONE, &swigoutput, "generate swig interface code (default)", NULL}, {"gear", '\0', 0, G_OPTION_ARG_NONE, &gearoutput, "generate gearbox interface code", NULL}, {"gir", '\0', 0, G_OPTION_ARG_NONE, &giroutput, "generate GIR (GObject-Introspection-Runtime)", NULL}, {"cxx", '\0', 0, G_OPTION_ARG_NONE, &cxxoutput, "output C++ code instead of SWIG interface", NULL}, {"", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &files, "vala/vapi input files", "FILE FILE .."}, {NULL}};

static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _result_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar** _tmp2_ = NULL;
	gboolean _tmp10_;
	const gchar* _tmp11_;
	gchar** _tmp13_;
	gint _tmp13__length1;
	gint count;
	gboolean _tmp15_;
	gboolean _tmp17_;
	gboolean _tmp19_;
	gboolean _tmp21_;
	gint _tmp23_;
	const gchar* _tmp25_ = NULL;
	const gchar* _tmp26_;
	const gchar* _tmp28_;
	gchar* _tmp29_;
	gchar* profile;
	gboolean _tmp30_;
	const gchar* _tmp32_;
	const gchar* _tmp33_;
	const gchar* _tmp34_;
	ValabindCompiler* _tmp35_;
	ValabindCompiler* vbc;
	gchar** _tmp36_;
	gint _tmp36__length1;
	gchar** _tmp46_;
	gint _tmp46__length1;
	ValabindCompiler* _tmp56_;
	const gchar* _tmp57_;
	gboolean _tmp69_;
	GError * _inner_error_ = NULL;
	_g_free0 (output);
	output = NULL;
	_tmp0_ = g_strdup (".");
	_g_free0 (vapidir);
	vapidir = _tmp0_;
	_tmp1_ = g_strdup ("");
	_tmp2_ = g_new0 (gchar*, 1 + 1);
	_tmp2_[0] = _tmp1_;
	files = (_vala_array_free (files, files_length1, (GDestroyNotify) g_free), NULL);
	files = _tmp2_;
	files_length1 = 1;
	_files_size_ = files_length1;
	{
		GOptionContext* _tmp3_;
		GOptionContext* opt_context;
		GOptionContext* _tmp4_;
		GOptionContext* _tmp5_;
		GOptionContext* _tmp6_;
		_tmp3_ = g_option_context_new ("- valabind");
		opt_context = _tmp3_;
		_tmp4_ = opt_context;
		g_option_context_set_help_enabled (_tmp4_, TRUE);
		_tmp5_ = opt_context;
		g_option_context_add_main_entries (_tmp5_, options, NULL);
		_tmp6_ = opt_context;
		g_option_context_parse (_tmp6_, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_option_context_free0 (opt_context);
			if (_inner_error_->domain == G_OPTION_ERROR) {
				goto __catch0_g_option_error;
			}
			_g_option_context_free0 (opt_context);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
		_g_option_context_free0 (opt_context);
	}
	goto __finally0;
	__catch0_g_option_error:
	{
		GError* e = NULL;
		FILE* _tmp7_;
		GError* _tmp8_;
		const gchar* _tmp9_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = stderr;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		fprintf (_tmp7_, "%s\nTry --help\n", _tmp9_);
		result = 1;
		_g_error_free0 (e);
		return result;
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp10_ = show_version;
	if (_tmp10_) {
		g_print ("%s\n", version_string);
		result = 0;
		return result;
	}
	_tmp11_ = modulename;
	if (_tmp11_ == NULL) {
		FILE* _tmp12_;
		_tmp12_ = stderr;
		fprintf (_tmp12_, "No modulename specified. Use --module or --help\n");
		result = 1;
		return result;
	}
	_tmp13_ = files;
	_tmp13__length1 = files_length1;
	if (_tmp13__length1 == 0) {
		FILE* _tmp14_;
		_tmp14_ = stderr;
		fprintf (_tmp14_, "No files given\n");
		result = 1;
		return result;
	}
	count = 0;
	_tmp15_ = swigoutput;
	if (_tmp15_) {
		gint _tmp16_;
		_tmp16_ = count;
		count = _tmp16_ + 1;
	}
	_tmp17_ = gearoutput;
	if (_tmp17_) {
		gint _tmp18_;
		_tmp18_ = count;
		count = _tmp18_ + 1;
	}
	_tmp19_ = giroutput;
	if (_tmp19_) {
		gint _tmp20_;
		_tmp20_ = count;
		count = _tmp20_ + 1;
	}
	_tmp21_ = cxxoutput;
	if (_tmp21_) {
		gint _tmp22_;
		_tmp22_ = count;
		count = _tmp22_ + 1;
	}
	_tmp23_ = count;
	if (_tmp23_ > 1) {
		FILE* _tmp24_;
		_tmp24_ = stderr;
		fprintf (_tmp24_, "Cannot use --swig, --gir, --gear or --cxx together\n");
		result = 1;
		return result;
	}
	_tmp26_ = useprofile;
	if (_tmp26_ != NULL) {
		const gchar* _tmp27_;
		_tmp27_ = useprofile;
		_tmp25_ = _tmp27_;
	} else {
		_tmp25_ = "posix";
	}
	_tmp28_ = _tmp25_;
	_tmp29_ = g_strdup (_tmp28_);
	profile = _tmp29_;
	_tmp30_ = glibmode;
	if (_tmp30_) {
		gchar* _tmp31_;
		_tmp31_ = g_strdup ("gobject");
		_g_free0 (profile);
		profile = _tmp31_;
	}
	_tmp32_ = modulename;
	_tmp33_ = vapidir;
	_tmp34_ = profile;
	_tmp35_ = valabind_compiler_new (_tmp32_, _tmp33_, _tmp34_);
	vbc = _tmp35_;
	_tmp36_ = packages;
	_tmp36__length1 = _vala_array_length (packages);
	if (_tmp36_ != NULL) {
		gchar** _tmp37_;
		gint _tmp37__length1;
		_tmp37_ = packages;
		_tmp37__length1 = _vala_array_length (packages);
		{
			gchar** pkg_collection = NULL;
			gint pkg_collection_length1 = 0;
			gint _pkg_collection_size_ = 0;
			gint pkg_it = 0;
			pkg_collection = _tmp37_;
			pkg_collection_length1 = _tmp37__length1;
			for (pkg_it = 0; pkg_it < _tmp37__length1; pkg_it = pkg_it + 1) {
				gchar* _tmp38_;
				gchar* pkg = NULL;
				_tmp38_ = g_strdup (pkg_collection[pkg_it]);
				pkg = _tmp38_;
				{
					const gchar* _tmp39_;
					gchar* _tmp40_;
					gchar* _tmp41_;
					gchar* _tmp42_;
					gchar* _tmp43_;
					ValabindCompiler* _tmp44_;
					const gchar* _tmp45_;
					_tmp39_ = pkg;
					_tmp40_ = g_strconcat ("Adding dependency ", _tmp39_, NULL);
					_tmp41_ = _tmp40_;
					_tmp42_ = g_strconcat (_tmp41_, "\n", NULL);
					_tmp43_ = _tmp42_;
					g_print ("%s", _tmp43_);
					_g_free0 (_tmp43_);
					_g_free0 (_tmp41_);
					_tmp44_ = vbc;
					_tmp45_ = pkg;
					valabind_compiler_add_external_package (_tmp44_, _tmp45_);
					_g_free0 (pkg);
				}
			}
		}
	}
	_tmp46_ = files;
	_tmp46__length1 = files_length1;
	{
		gchar** file_collection = NULL;
		gint file_collection_length1 = 0;
		gint _file_collection_size_ = 0;
		gint file_it = 0;
		file_collection = _tmp46_;
		file_collection_length1 = _tmp46__length1;
		for (file_it = 0; file_it < _tmp46__length1; file_it = file_it + 1) {
			gchar* _tmp47_;
			gchar* file = NULL;
			_tmp47_ = g_strdup (file_collection[file_it]);
			file = _tmp47_;
			{
				const gchar* _tmp48_;
				gint _tmp49_ = 0;
				ValabindCompiler* _tmp54_;
				const gchar* _tmp55_;
				_tmp48_ = file;
				_tmp49_ = string_index_of (_tmp48_, ".vapi", 0);
				if (_tmp49_ == (-1)) {
					ValabindCompiler* _tmp50_;
					ValabindCompiler* _tmp51_;
					const gchar* _tmp52_;
					gchar* _tmp53_;
					_tmp50_ = vbc;
					_tmp50_->pkgmode = TRUE;
					_tmp51_ = vbc;
					_tmp52_ = file;
					_tmp53_ = g_strdup (_tmp52_);
					_g_free0 (_tmp51_->pkgname);
					_tmp51_->pkgname = _tmp53_;
				}
				_tmp54_ = vbc;
				_tmp55_ = file;
				valabind_compiler_add_source_file (_tmp54_, _tmp55_);
				_g_free0 (file);
			}
		}
	}
	_tmp56_ = vbc;
	valabind_compiler_parse (_tmp56_);
	_tmp57_ = output;
	if (_tmp57_ == NULL) {
		const gchar* _tmp58_ = NULL;
		gboolean _tmp59_;
		const gchar* _tmp66_;
		const gchar* _tmp67_;
		gchar* _tmp68_ = NULL;
		_tmp59_ = giroutput;
		if (_tmp59_) {
			_tmp58_ = "gir";
		} else {
			const gchar* _tmp60_ = NULL;
			gboolean _tmp61_;
			const gchar* _tmp65_;
			_tmp61_ = gearoutput;
			if (_tmp61_) {
				_tmp60_ = "gear";
			} else {
				const gchar* _tmp62_ = NULL;
				gboolean _tmp63_;
				const gchar* _tmp64_;
				_tmp63_ = cxxoutput;
				if (_tmp63_) {
					_tmp62_ = "cxx";
				} else {
					_tmp62_ = "i";
				}
				_tmp64_ = _tmp62_;
				_tmp60_ = _tmp64_;
			}
			_tmp65_ = _tmp60_;
			_tmp58_ = _tmp65_;
		}
		_tmp66_ = modulename;
		_tmp67_ = _tmp58_;
		_tmp68_ = g_strdup_printf ("%s.%s", _tmp66_, _tmp67_);
		_g_free0 (output);
		output = _tmp68_;
	}
	_tmp69_ = gearoutput;
	if (_tmp69_) {
		ValabindCompiler* _tmp70_;
		const gchar* _tmp71_;
		gboolean _tmp72_;
		gboolean _tmp73_;
		gboolean _tmp74_;
		const gchar* _tmp75_;
		_tmp70_ = vbc;
		_tmp71_ = output;
		_tmp72_ = show_externs;
		_tmp73_ = glibmode;
		_tmp74_ = cxxmode;
		_tmp75_ = includefile;
		valabind_compiler_emit_gear (_tmp70_, _tmp71_, _tmp72_, _tmp73_, _tmp74_, _tmp75_);
	} else {
		gboolean _tmp76_;
		_tmp76_ = giroutput;
		if (_tmp76_) {
			ValabindCompiler* _tmp77_;
			const gchar* _tmp78_;
			gboolean _tmp79_;
			gboolean _tmp80_;
			gboolean _tmp81_;
			const gchar* _tmp82_;
			_tmp77_ = vbc;
			_tmp78_ = output;
			_tmp79_ = show_externs;
			_tmp80_ = glibmode;
			_tmp81_ = cxxmode;
			_tmp82_ = includefile;
			valabind_compiler_emit_gir (_tmp77_, _tmp78_, _tmp79_, _tmp80_, _tmp81_, _tmp82_);
		} else {
			gboolean _tmp83_;
			_tmp83_ = cxxoutput;
			if (_tmp83_) {
				ValabindCompiler* _tmp84_;
				const gchar* _tmp85_;
				gboolean _tmp86_;
				gboolean _tmp87_;
				gboolean _tmp88_;
				const gchar* _tmp89_;
				_tmp84_ = vbc;
				_tmp85_ = output;
				_tmp86_ = show_externs;
				_tmp87_ = glibmode;
				_tmp88_ = cxxmode;
				_tmp89_ = includefile;
				valabind_compiler_emit_cxx (_tmp84_, _tmp85_, _tmp86_, _tmp87_, _tmp88_, _tmp89_);
			} else {
				ValabindCompiler* _tmp90_;
				const gchar* _tmp91_;
				gboolean _tmp92_;
				gboolean _tmp93_;
				const gchar* _tmp94_;
				_tmp90_ = vbc;
				_tmp91_ = output;
				_tmp92_ = show_externs;
				_tmp93_ = glibmode;
				_tmp94_ = includefile;
				valabind_compiler_emit_swig (_tmp90_, _tmp91_, _tmp92_, _tmp93_, TRUE, _tmp94_);
			}
		}
	}
	result = 0;
	_valabind_compiler_unref0 (vbc);
	_g_free0 (profile);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



